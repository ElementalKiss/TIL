# 웹프로그래밍 이해

## 웹 프로그래밍이란?

### 정의 
* HTTP 프로그톨로 통신하는 클라이언트와 서버를 개발 하는 것.
* 장고는 이를 돕는 웹 프레임워크
* 웹 클라이언트 리퀘스트 -> http/https 프로토콜 -> 웹 서버 리스폰

### 웹 클라이언트의 종류
* 웹 브라우저
* 리눅스 curl
http/https/ftp 등 여러가지의 프로토콜을 사용하여 데이터를 송수신할 수 있는 명령
* Telnet
* 직접 만든 클라이언트

## HTTP 프로토콜
Hypertext Transfer Protocol로 웹 서버와 웹 클라이언트 사이에서 데이터를 주고받기 위해 사용하는 통신 방식으로 TCP/IP 프로토콜 위에서 동작한다.

### HTTP 메시지 구조
* 스타트라인(Start Line) - 요청라인 또는 상태라인
* 헤더(Header) - 헤더는 생략 가능
* 빈 줄(Blank Line) - 헤더의 끝을 빈 줄로 식별
* 바디(Body) - 바디는 생략 가능

요청 메시지인 경우 요청라인, 응답 메시지인 경우 상태라인이라 한다. 스타트라인에 이어 헤더는 각 행의 끝에 줄 바꿈 문자인 CRLF(Carriage Return Line Feed)가 있으며, 헤더와 바디는 빈 줄로 구분된다. 헤더와 바디는 생략할 수 있고 바디에는 텍스트뿐만 아니라 바이너리 데이터도 들어갈 수 있다.

* 요청 메시지 예시
```
GET /book/shakespeare HTTP/1.1
Host: example.com:8080
```
첫 번째 줄은 요청라인 Method, URI, Protocol Version으로 구성된다.
두 번째 줄은 Name: Value 형식으로 표현하며, 여러 줄도 가능하다. Host 항목은 필수이다. 요청 라인 URI에 Host를 표시하면 헤더는 생략 가능하다.

* 요청 메시지 헤더 생략 가능 예시
```
GET http://exmaple.com:8080/book/sharespeare HTTP/1.1
```

* 응답 메시지 예시
```
HTTP/1.1 200 OK
Context-Type: application/xhtml+xml; charset=utf-8

<html>
...
</html>
```

첫 번째 줄은 상태라인으로 Protocol Version, 상태 코드, 상태 텍스트로 구성된다.
두 번재 줄부터는 헤더이다. 헤더 항목이 하나뿐인 응답 메시지로, 바디와 헤더가 빈 줄로 구분되어있다. 바디에는 HTML을 포함한다.

* URI란?

Uniform Resource Indentifier의 약자로 URL(Uniform Resource Locator)과 URN(Uniform Resource Name)을 포함하는 좀 더 넓은 의미의 표현이다.

### HTTP 처리 방식
* GET: 리소스 취득. Read(조회)
* POST: 리소스 생성. Create(생성)
* PUT: 리소스 변경. Update(변경)
* Delete: 리소스 삭제. Delete(삭제)
* HEAD: 리소스의 헤더(메타데이터) 취득
* OPTIONS: 리소스가 서포트하는 메소드 취득
* TRACE: 루프백 시험에 사용
* CONNECT: 프록시 동작의 터널 접속으로 변경

### GET과 POST 메소드

HTML 폼에서 지정할 수 있는 메소드가 GET과 POST 밖에 없어 가장 많이 쓰는 메소드.

* GET 방식은 URI 부분의 ? 뒤에 Key=Value 쌍으로 이어붙여 보낸다.
* POST 방식은 GET의 URI에 넣던 것을 요청 메시지의 바디에 넣는다.

### 상태 코드

서버에서의 처리 결과는 응답 메시지의 상태라인에 있는 상태코드(Status Code)를 보고 파악할 수 있다.

[Status Code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)

## URL 설계

* 디자인 측면에서 화면 UI 설계하고, 프로그램 로직 측면에서는 URL을 설계한다.
* URL 설계는 웹 서버 로직 설계의 첫걸음
* 사용자 또는 웹 클라이언트에게 웹 서버가 가지고 있는 기능을 명시해주기 때문에 중요한 단계

### URL 구성

http://www.example.com:80/services?category=2&kind=patents#n10 <br>
[URL스킴]://호스트명:포트번호/경로?쿼리스트링#프라그먼트

* URL 스킴: URL에 사용된 프로토콜을 의미한다.
* 호스트명: 웹 서버의 호스트명, 도메인명 또는 IP 주소로 표현한다.
* 포트번호: 웹 서버 내의 서비스 포트번호이다. 생략 시에는 디폴트 포트번호로, http는 80, https는 443을 사용한다.
* 경로: 파일이나 애플리케이션 경로를 의미한다.
* 쿼리스트링: 질의 문자열로, &로 구분된 key=value 형식으로 표현한다.
* 프라그먼트: 문서 내의 앵커 등 조각을 지정한다.

### URL을 바라보는 측면

URL은 웹 서버에 존재하는 애플리케이션에 대한 API(Application Programming Interface)라고 할 수 있다. 이 API의 명명 규칙을 정하는 두 가지 방법이 있는데 RPC(Remote Procedure Call)과 REST(Representational State Transfer)가 있다.

* RPC

클라이언트가 네트워크상에서 원격에 있는 서버가 제공하는 API 함수를 호출하는 방식이다. URL 설계와 API 설계를 동일하게 고려해 URL의 경로를 API 함수명으로, 쿼리 파라메터를 함수의 인자로 간주한다. 웹 클라이언트에서 URL을 전송하는 것이 웹 서버의 API 함수를 호출한다고 인식하는 것.

```
http://blog.example.com/search?q=test&debug=true
```

* REST

웹 서버에 존재하는 요소들을 모두 리소스라고 정의한다. URL을 통해 웹 서버의 특정 리소스를 표현한다는 개념이다. 리소스는 상태가 변할 수 있기 때문에 CS간에 리소스 상태의 교환(Representational State Transfer)로 간주한다. 리소스에 대한 조작은 GET, POST, PUT, DELETE 등의 http 메소드로 맵핑한다.

### 파이썬의 우아한 URL

```
url(r'^articles/(\d{4})/(\d{2})/(\d+)/$', views.article_detail),
```

* r: 이스케이프되지 않는 raw 스트링을 표시함
* ^: 패턴의 시작을 표시함
* \d{4}: 4자리 숫자를 의미함
* $: 패턴의 끝을 표시

만일 URL이 /articles/2015/03/1이라면, views.article_detail(request, '2015', '03', '1')을 호출한다.

& 전혀 우아해보이지 않는 것은 기분 탓인가....

## 웹 애플리케이션 서버

* 웹 서버

웹 클라이언트의 요청을 받아서 요청을 처리하고 그 결과를 웹 클라이언트에게 응답한다. 주로 정적 페이지인 HTML과 이미지, CSS, 자바스크립트 파일을 웹 클라이언트에게 제공할 때 웹 서버를 사용한다. 만약 동적 페이지 처리가 필요하다면 웹 애플리케이션 서버에 처리를 넘긴다.

Apache httpd, Nginx, lighttpd, IIS 등

* 웹 애플리케이션 서버
웹 서버로부터 동적 페이지 요청을 받아서 요청을 처리하고, 그 결과를 웹 서버로 반환한다. 주로 동적 페이지 생성을 위한 프로그램 실행과 데이터베이스 연동 기능을 처리한다.

Apache Tomcat, JBoxx, WebLogic, WebSphere, Jetty, Jeus 등

### 정적 페이지와 동적 페이지

* 정적 페이지: 누가, 언제 요구하더라도 같은 내용을 표시하는 웹 페이지.
* 동적 페이지: 누가, 언제, 어떻게 요구했는지에 따라 각각 다른 내용이 반환되는 페이지.

정적, 동적이란 용어는 사용자가 페이지를 요청하는 시점에 페이지의 내용이 유지되는가 변경되는가를 구분해주는 용어이다. 즉, 동적 페이지에는 프로그래밍 코드가 포함되어 있어 페이지 요청 시점에 HTML 문장을 만들어 내는 것이다.

동적 페이지의 요구가 많아짐에 따라 웹 서버와는 다른 별도의 프로그램이 필요하게 되었다. 이런 별도의 프로그램과 웹 서버 사이에 정보를 주고받는 규칙을 정의한 것이 CGI(Common Gateway Interface) 규격이다.

### CGI 방식의 단점

CGI 자체는 정식 프로그래밍 언어나 스크립트가 아니라, 웹 서버와 독립적인 프로그램(프로세스) 사이에 정보를 주고받는 규격이다. 전통적인 CGI 방식은 웹 서버가 C, C++, Perl, PHP 등으로 만들어진 CGI 프로그램을 직접 호출하여 개별 프로세스를 생성하는 방식이다.

요청이 많아질수록 프로세스가 많아지고 메모리 요구량도 커져 시스템에 많은 부하를 준다.

### CGI 방식의 대안 기술

CGI 방식의 대안 기술 중 하나는 별로의 애플리케이션을 스크립트 언어로 작성하고 이를 웹 서버에 내장시켜 별도 프로세스에서 오는 오버헤드를 줄인다. 파이썬의 경우 이전엔 mod_python을 사용했지만 현재는 mod_wsgi 모듈을 사용하고 있다.

또 다른 방식은 애플리케이션을 처리하는 프로세스를 미리 데몬으로 기동시켜 놓은 후, 웹 서버의 요청을 데몬에서 처리하는 것이다. 파이썬의 경우 데몬 방식도 mod_wsgi 모듈을 사용한다.

CGI 애플리케이션을 별도의 데몬으로 처리하는 방식은 기술이 점차 발전하여 스레드 처리가 보강되고 객체 지향 기술이 반영되면서 애플리케이션 전용 데몬인 애플리케이션 서버 방식으로 발전했다. 현재 가장 많이 사용되는 기술은 JSP, ASP 기술이다.

### 애플리케이션 서버 방식

애플리케이션 서버 방식은 웹 서버가 직접 프로그램을 호출하기 보단 웹 애플리케이션 서버를 통해 간접적으로 웹 애플리케이션 프로그램을 실행한다. 웹 애플리케이션 서버는 애플리케이션 프로그램의 실행 결과를 웹 서버에 전달해주며, 웹 서버는 웹 애플리케이션 서버로부터 응답 결과를 웹 클라이언트에게 전송한다.

웹 서버와 웹 애플리케이션 서버가 분리됨에 따라 역할을 구분하여 페이지를 처리해야 한다. 웹 서버는 정적 페이지를 처리하고 웹 애플리케이션 서버는 동적 페이지를 처리하도록 분담하는 것이 효율적이다.

