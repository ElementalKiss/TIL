# 1장 튜토리얼

## 1.1 Hello. World

### 코드 작성해보기

```go
package main

import fmt

func main() {
    fmt.Println("Hello, 세상아")
}
```

* Go는 컴파일되는 언어이다.
* Go 툴체인(toolchain)은 소스 프로그램과 그에 종속된 것들을 기계어로 변환한다.
* 유니코드를 직접 처리하므로 전 세계 언어로 작성된 텍스르를 처리할 수 있다.

### 컴파일 후 확인해보기

```
$ go run helloworld.go
```

* run은 일회성 테스트를 위해 컴파일 후 결과를 확인 하는 것이다.

### 빌드해서 바이너리 뽑아보기

```
$ go build helloworld.go
$ ./helloworld
Hello, 세상아
```

* 빌드 결과를 바이너리 파일로 저장하고 싶으면 build 툴체인을 사용하면 된다.

### 외부에서 소스코드 가져오기

```
$ go get gopl.io/ch1/helloworld
```

* 위의 명령어를 실행하면 코드를 가져올 수 있다.
* go env를 통해 $GOPATH를 확인해보고 해당 경로에 저장되는 것을 확인해야 한다. (실행했던 경로에 파일이 생기지 않아 한참 찾았다.)

### Go 언어에 대해..

* 패키지
    + 패키지는 다른 언어의 라이브러리나 모듈과 유사한 개념이다.
    + 패키지는 역할을 정의하는 하나의 디렉토리와 이 디렉토리 안에 있는 하나 이상의 .go 파일로 이뤄진다.
    + 각 소스 파일은 파일이 속하는 패키지를 나타내는 package 정의로 시작한다.
    + 그 뒤에 소스 파일에서 임포트하는 다른 패키지 목록, 이 파일에 저장돼 있는 프로그램의 선언 목록이 순서대로 이어진다.

* 표준 라이브러리
    + 입력과 출력, 정렬, 텍스트 조작과 같은 범용적 작업을 위한 100개 이상의 패키지가 들어있다.

* 패키지 main
    + '패키지 main'은 독립 실행형 프로그램을 정의한다.
    + '패키지 main'의 'main 함수'는 실행 시 프로그램이 시작되는 지점으로 main이 수행하는 것이 곧 프로그램이 수행하는 것이다.
    
* import
    + import 선언을 통해 컴파일러에게 소스 파일에 필요한 패키지를 알려줘야한다.

* 함수 선언
    + 키워드 func, 함수명, 파라미터 목록, 결과 목록, 함수 본문이 중괄호로 묶인 형태로 이뤄져 있다.

* 문장의 형태와 유의해야 할 점
    + 문장이 한 줄에 두 개 이상 나오는 경우 외에는 문장이나 선언의 끝에 세미콜론을 요구하지 않는다.
    + 특정 토큰 뒤의 개행문자가 세미콜론으로 변환되므로 개행문자의 위치는 Go 코드의 해석에 영향을 준다.
    + 중괄호 {는 func 선언과 같은 줄에 위치해야 하며, x + y에서 개행문자는 +의 뒤에만 허용된다.

* 코드 서식의 강경함
    + gofmt 도구는 코드를 표준 형식으로 재작성한다.
    + go 도구의 fmt 부속 명령은 지정된 패키지 내의 모든 파일이나 현재 디렉토리의 파일에 gofmt를 적용한다.
    + 표준 포멧을 명시적으로 선언하는 것은 사소한 일에 대한 수많은 무의미한 논쟁을 없앤다.
    + 다양한 자동화된 소스코드 변환을 가능하게 한다.

---

## 1.2 커맨드라인 인수

---

### os 패키지와 명령인수

* os 패키지와 Args
    + os 패키지는 플랫폼에 독립적으로 운영체제를 제어하는 함수와 기타 값들을 제공한다.
    + 커맨드라인 인수는 os 패키지의 일부인 Args 변수로 사용할 수 있다.
    + os.Args 변수는 문자열의 슬라이스이다. 슬라이스는 Go의 기본 개념.

* arg 접근법
    + 우선은 s[i]로 각 부분 집합은 s[m:n]으로 접근할 수 있는 동적인 크기의 배열 원소의 모음 정도로 생각하면 된다.
    + 0 <= m <= n <= len(s)인 슬라이스 s[m:n]은 n-m개의 원소를 가진다.
    + os.Args의 첫 번째 원소인 osArgs[0]은 명령 자체의 이름이다.
    + m or n은 생략된 경우 기본은 0과 len(s)로 정의된다.

### os 패키지 활용 예제

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```

* 커맨드라인 인수를 echo로 출력하는 구현이다.
* var 선언은 문자열 타입의 두 변수 s, sep을 선언한다.
* 명시적으로 초기화 하지 않으면 숫자형은 0, 문자형은 ""이다.
* for 루프는 Go의 유일한 루프문이다.

### echo 예제를 for 루프로 출력하는 예제

```go
for 초기화; 조건; 후처리 {
    // 0개 이상의 구문
}

// 전통적인 while 루프
for 조건 {
    // ...
}

// 전통적인 무한 루프
for {
    // ...
}
```

* break 또는 return문과 같은 다른 방법으로 빠져나올 수 있다.

### range를 이용해 범위 기반으로 출력하는 예제

```go
func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
```

* range는 루프의 각 반복에서 인덱스와 그 인덱스에 있는 원소 값의 쌍을 생성한다.
* 해당 예제는 인덱스가 필요하지 않으므로 _ 언더바로 빈 식별자를 명시적으로 작성한다.

### 변수 선언 방법

```go
s := ""
var s string
var s = ""
var s string = ""
```

* 모두 문자열 변수를 선언하는 방법이다. 모두 동일하다.
* 첫 번째: 가장 간결하지만 패키지 수준 변수가 아닌 함수 안에서만 사용할 수 있다.
* 두 번쨰: 문자열의 기본 초기 값에 의존하는 형식이다.
* 세 번째: 여러 변수를 선언하는 경우 외에는 거의 사용되지 않는다.
* 네 번째: 변수의 타입과 초기 값의 타입이 같아 선언이 중복되므로 명시적으로 선언할 필요가 없다.
* 주로 첫 번째와 두 번째 형식을 사용하게 될 것이다.

```go
func main() {
	fmt.Println(strings.Join(os.Args[1:], " "))
}
```

* 간단히  string 패키지를 이용해 출력하는 방법도 있다.

## 1.3 중복 줄 찾기

---

### bufio 패키지

* 입력을 읽고 줄이나 단어 단위로 나누는 Scanner 타입이 있다.

```go
input := bufio.NewScanner(os.Stdin)
```

* bufio.Scanner를 참조하는 새 변수 input을 생성한다.
* 스캐너는 프로그램의 표준 입력을 읽는다.
* input.Scan()을 호출할 때마다 다음 줄을 읽고 마지막 개행 문자를 제거한다.
* input.Text()를 통해 결과를 출력할 수 있다.
* Scan 함수는 줄이 있으면 ture, 더 이상 입력이 없으면 false를 반환한다.

## 1.4 애니메이션 GIF

* Go에 내장된 표준 이미지 패키지 기본 사용법을 설명한다.
* 그냥 예제만 해보면 될 듯 하다.