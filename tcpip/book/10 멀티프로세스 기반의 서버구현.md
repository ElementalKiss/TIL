# 10 멀티프로세스 기반의 서버구현

## 10-1 프로세스의 이해와 활용

### 두 가지 유형의 서버

* 유형1: 첫 번째 연결요청자는 대기 0초, 50번째 연결요청자는 50초. 그러나 일단 연결되면 1초 안에 서비스 완료.
* 유형2: 모든 연결요청자가 접속대기시간 1초 이하, 서비스 제공받는데 걸리는 시간은 평균 2~3초.

### 다중접속 서버의 구현방법들

* 멀티프로세스 기반 서버: 다수의 프로세스를 생성하는 방식으로 서비스 제공(Linux 한정)
* 멀티플렉싱 기반 서버: 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공
* 멀티쓰레딩 기반 서버: 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공

### 프로세스(Process)의 이해

* 정의: 메모리 공간을 차지한 상태에서 실행중인 프로그램
* 벽돌깨기 프로그램을 다운 받으면 그것은 프로그램, 실행해서 메모리에 올라가면 프로세스.

### 프로세스 ID

* 2 이상의 정수 형태.(1은 운영체제가 시작하자마자 운영체제를 돕는 프로세스에 부여)
* ps au 명령을 통해 확인 가능.

### fork 함수호출을 통한 프로세스의 생성

```cpp
#include<unistd.h>

pid_t fork(void);
// 성공 시 프로세스 ID, 실패 시 -1
```

* fork 함수는 호출한 프로세스의 복사본을 생성.
* 부모 프로세스(원본 프로세스)와 자식 프로세스(복사본)는 모두 fork 함수 이후 문장을 실행.
* 부모 프로세스: fork 함수의 반환 값은 자식 프로세스의 ID
* 자식 프로세스: fork 함수의 반환 값은 0

## 10-2 프로세스 & 좀비(Zombie) 프로세스

### 좀비 프로세스

* 할 일을 다 하고 사라지지 않는 프로세스

### 좀비 프로세스의 생성 이유

* 자식 프로세스 종료 원인1: 인자를 전달하며 exit를 호출하는 경우
* 자식 프로세스 종료 원인2: main 함수에서 return문을 실행하면서 값을 리턴하는 경우
* 위 return 값은 운영체제에게 전달 되는데 이를 다시 자식 프로세스를 생성한 부모 프로세스에게 보내는데 이것이 전달되는 상황에 놓인 프로세스가 좀비 프로세스.
* 부모 프로세스가 적극적으로 운영체제에게 자식 프로세스 값을 요청해야 함.

### 좀비 프로세스의 소멸1: wait 함수의 사용

```cpp
#include <sys/wait.h>

pid_t wait(int* statloc);
// 성공 시 종료된 자식 프로세스의 ID, 실패 시 -1
```

* 자식 프로세스가 전달한 값은 두 메크로 함수로 분리 하여 정보를 알 수 있음.
* WIFEXITED: 자식 프로세스가 정상 종료한 경우 true를 리턴
* WEXITSTATUS: 자식 프로세스의 전달 값을 리턴

```cpp
if (WIFEXITED(status)) { // 정상 종료인가?
    printf("Child pass num: %d", WEXITSTATUS(status)); // 반환 값 출력
}
```

### 좀비 프로세스의 소멸2: waitpid 함수의 사용

```cpp
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* statloc, int options);
// 성공 시 종료된 자식 프로세스의 ID, 실패 시 -1
```

## 10-3 시그널 핸들링

* 부모도 자식만큼 바쁜데 무작정 wait를 할 수 없음.

### 운영체제에게 알려달라고 하기

* Signal Handleing: 특정 상황이 발생했음을 운영체제가 프로세스에게 전달하고 이를 처리하기 위해 미리 정의된 작업이 진행되는 것.

### Signal과 Signal 함수

* 프로세스: 내가 생성한 자식 프로세스 종료되면 zombie_handler 함수 좀 호출해줘.
* 운영체제: 오키. zombie_handler를 호출해줄테니 그 상황에 실행해야 할 문장들을 그 함수에 잘 정의해줘.

```cpp
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// 시그널 발생시 호출되도록 이전에 등록된 함수의 포인터 반환

// 함수 이름: signal
// 매개변수 선언: int signo, void(*func)(int)
// 반환형: 매개변수형이 int이고 반환형이 void인 함수 포인터
```

* 매개변수 첫 번째 인자로는 특정 상황에 대한 정보
    + SIGALRM: alarm 함수호출을 통해 등록된 시간이 된 상황
    + SIGINT: CTRL_C가 입력된 상황
    + SIGCHLD: 자식 프로세스가 종료된 상황

* 매개변수 두 번째 인자는 특정 상황에 호출될 함수의 주소 값(포인터)
    + 자식 프로세스가 종료되면 mychild 함수를 호출해 달라 = signal(SIGCHLD, mychild);
    + alarm 함수호출을 통해서 등록된 시간이 지나면 timeout 함수를 호출해 달라 = signal(SIGALRM, timeout);
    + CTRL+C가 입력되면 keycontrol 함수를 호출해 달라 = signal(SIGINT, keycontrol);

```cpp
#include <unistd.h>
unsigned int alarm(unsigend int seconds);
// 0 또는 SIGALRM 시그널이 발생하기까지 남아있는 시간을 초단위로 반환
```

* 위 함수를 호출하며 양의 정수를 인자로 전달. 전달된 수에 해당하는 시간이 지나서 SIGALRM 시그널이 발생.
* 0을 인자로 전달하면 이전에 설정된 SIGALRM 시그널 발생 예약이 취소.
* 시그널 발생 예약만 해놓고 호출되어야 할 함수를 지정하지 않으면 프로세스가 종료되어 버림.

### signal handling using sigaction

* signal 함수와 유사하며 훨씬 안정적으로 동작.
* signal 함수는 Unix 운영체제 별로 동작방식에 차이를 보일 수 있으나 sigaction 함수는 차이가 없음.
* 실제로 요즘은 signal 함수를 사용하지 않음.

```cpp
#include <signal.h>
int sigaction(int signo, const struct sigaction* act, struct sigaction* oldact);
// 성공 시 0, 실패 시 -1
```

* signo: signal 함수와 마찬가지로 시그널의 정보를 인자로 전달.
* act: 시그널 발생시 호출될 함수
* oldact: 이전에 등록되었던 시그널 핸들러의 함수 포인터를 얻는데 사용되는 인자. 필요없다면 0.

```cpp
// sigaction 구조체
struct sigaction
{
    void (*sa_handler)(int)
    sigset_t sa_mask;
    int sa_flags;
}
```
