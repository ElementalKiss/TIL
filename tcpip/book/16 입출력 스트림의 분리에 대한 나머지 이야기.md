# 16 입출력 스트림의 분리에 대한 나머지 이야기

## 16-1 입력 스트림과 출력 스트림의 분리

### 두 번의 입출력 스트림 분리

* 앞서 두 가지 방법으로 입력 스트림과 출력 스트림을 분리 했음.
* 첫 번째 분리
  * TCP 입출력 루틴 분할에서 fork 함수호출을 통해 파일 디스크립터를 하나 복사, 입력과 출력에 사용되는 파일 디스크립터를 구분.
* 두 번째 분리
  * fdopen 함수호출을 통해 읽기모드의 FILE 포인터와 쓰기모드의 FILE 포인터를 생성했다.
  * 입출력에 대한 도구가 구분 되었기 때문에 이 역시 스트림의 분리.

### 스트림 분리의 이점

* 첫 번째 분리
  * 입력루틴과 출력루틴의 독립을 통한 구현의 편의성 증대
  * 입력에 상관없이 출력이 가능하게 하여 속도 향상 기대
* 두 번째 분리
  * FILE 포인터는 읽기모드와 쓰기모드를 구분해야 하므로 해당 구분을 통한 구현의 편의성 증대
  * 모드 구분을 통한 버퍼링 기능 향상

### 스트림 분리 이후의 EOF에 대한 문제점

* half-close에 대해 기억하라.
* 두 번째 방법인 fdopen 함수호출 기반 스트림 분리인 경우 half-close가 어떻게 동작하는지 알아야 됨.
* "half-close는 출력 모드의 FILE 포인터를 대상으로  fclose 함수를 호출하면 되는것 아닌가? EOF가 전달되면서 데이터의 수신은 가능하되 송신이 불가능한 half-close 상황이 연출될 것 같다."
* 하지만 fdopen 함수호출로 만들어진 FILE 포인터를 대상으로 half-close를 사용하기 위해선 무엇인가를 해줘야 함.
* 그냥 사용했다간 쓰기는 물론, 읽기도 불가능한 완전 종료로 이어진다.

## 16-2 파일 디스크립터의 복사와 Half-close

### 스트림 종료 시 half-close가 진행되지 않는 이유

* 읽기모드 FILE 포인터와 쓰기모드 FILE 포인터는 하나의 파일 디스크립터를 기반으로 생성되므로 어떠한 FILE 포인터를 대상으로 fclose 함수를 호출하더라도 파일 디스크립터가 종료됨.
* half-close가 가능한 상태로 만들려면 복사를 통해 파일 디스크립터를 하나 더 만들면 된다.
* 이렇게 복사 하면 half-close가 될 듯 하지만 아직도 아님.

### 파일 디스크립터의 복사

* fork 함수호출 시 진행되는 복사와 차이가 있음.
* 원본과 복사본이 하나의 프로세스 내에 존재하는 형태의 복사를 의미.
* "동일한 파일 또는 소켓의 접근을 위한 또 다른 파일 디스크립터의 생성"
* 흔히 복사는 파일 디스크립터의 정수 값까지 복사한다고 생각하기 쉽지만 여기서 말하는 복사는 아님.

### dup & dup2

```cpp
#include <unistd.h>
int dup(int fildes);
int dup2(int fildes, int fildes2);
// 성공 시 복사된 파일 디스크립터, 실패 시 -1
```

* dup2 함수는 복사된 파일 디스크립터의 정수 값을 명시적으로 지정할 때 사용.
* 0보다 크고 프로세스당 생성할 수 있는 파일 디스크립터의 수보다 작은 값을 전달하면, 해당 값을 복사 되는 파일 디스크립터의 정수 값으로 지정해줌.