# 17 select보다 나은 epoll

## 17-1 epoll의 이해와 활용

* select는 오래 전 개발된 멀티플랙싱 기법으로 허용할 수 있는 동접수가 100을 넘기 어렵다.(하드웨어 성능에 따라 편차가 크다.)
* 오늘날 개발환경에 적절치 않고 그 대안으로 epoll을 사용.

### select기반의 IO 멀티플렉싱이 느린 이유

* select 함수호출 이후에 항상 등장하는 모든 파일 디스크립터를 대상으로 하는 반복문
* select 함수를 호출할 때마다 인자로 매번 전달해야하는 관찰대상에 대한 정보들
* select 함수는 소켓(운영체제가 관리)의 변화를 관찰하는 함수이기때문에 매번 운영체제의 도움을 받아야 한다.
* 위의 select의 단점을 해결하는 방법
    * 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려준다.
    * 관찰대상의 범위, 내용에 변경이 있을 때 변경 사항만 알려주도록 한다.
    * 단, 운영체제가 이 방식에 동의할 경우. 즉 그 기능을 지원하는지가 중요하다. 리눅스는 epoll 윈도우는 IOCP

### select를 사용처와 장점

* 서버의 접속자 수가 적다.
* 다양한 운영체제에서 운영이 가능하다.

### epoll의 구현에 필요한 함수와 구조체

* 상태변화의 확인을 위한 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
* select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번 전달할 필요가 없다.

```cpp
epoll_create // epoll 파일 디스크립터 저장소 생성
epoll_ctrl   // 저장소에 파일 디스크립터 등록 및 삭제
epoll_wait   // select 함수와 마찬가지로 파일 디스크립터의 변화를 대기
```

### epoll_create

```cpp
#include <sys/epoll.h>
int epoll_create(int size);
// 성공 시 epoll 파일 디스크립터, 실패 시 -1 반환
```

* epoll_create 함수호출 시 생성되는 파일 디스크립터의 저장소를 가리켜 'epoll 인스턴스'라 한다.
* 그러나 변형되어서 다양하게 불리고 있으니 주의.
* size는 epoll 인스턴스가 생성될 크기가 아닌 운영체제가 참고할 힌트 역할만 한다.
* 해당 함수로부터 반환되는 파일 디스크립터는 운영체제에 의해 관리된다.
* 반환하는 파일 디스크립터는 epoll 인스턴스를 구분하는 목적으로 사용되며 소멸 시에 close 함수호출을 통한 종료 과정이 필요하다.

### epoll_ctl

```c
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);
// 성공 시 0, 실패 시 -1
/*
epfd  관찰대상을 등록할  epoll 인스턴스의 파일 디스크립터.
op    관찰대상의 추가, 삭제 또는 변경여부 지정.
fd    등록할 관찰대상의 파일 디스크립터.
event 관찰대상의 관찰 이벤트 유형.
*/
```

### epoll_wait

```c
#include <sys/epoll.h>
int dpoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);
// 성공 시 이벤트가 발생한 파일 디스크립터의 수, 실패 시 -1
/*
events      이벤트가 발생한 파일디스크립터가 채워질 버퍼의 주소 값.
maxevents   두 번째 인자로 전달된 주소 값의 버퍼에 등록 가능한 최대 이벤트 수.
timeout     ms 단위 대기시간. -1 전달 시, 이벤트 발생까지 무한 대기.
*/
```

## 17-2 레벨 트리거와 엣지 트리거

### 레벨 트리거와 엣지 트리거의 차이는 이벤트가 발생하는 시점

* 레벨 트리거 방식은 입력버퍼에 데이터가 남아있는 동안에 계속해서 이벤트를 등록
* 엣지 트리거는 딱 한번만 이벤트가 등록된다. 입력버퍼에 데이터가 남아있다고 해서 이벤트를 추가로 등록하지 않는다.

### 엣지 트리거 기반의 서버 구현을 위해 알아야 할 두 가지

* 변수 errno을 이용한 오류의 원인을 확인하는 방법
    * int errno을 사용하려면 error.h 헤더에 extern 선언이 존재하여 이를 포함해서 사용해야 한다.
    * 오류 발생 시 변수 errno에 저장되는 값이 다 다르기 때문에 모두 알 필요는 없다.
    * read 함수는 입력버퍼가 비어서 더 이상 읽어 들일 데이터가 없을 때 -1을 반환하고 errno에 상수 EAGAIN가 저장된다.(중요)
* Non Blocking IO를 위한 소켓 특성을 변경하는 방법
    * 파일을 Non Blocking 모드로 변경하기 위해선 다음 두 문장 실행.
    ```c
    int flag = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flag|O_NONBLOCK);
    ```
    * read&write 함수 호출 시에도 데이터의 유무에 관계 없이 블로킹 되지 않는 파일(소켓)이 완성 되었다.


### 레벨 트리거와 엣지 트리거 중 더 좋은 것은?

* 엣지 트리거는 데이터의 수신과 데이터가 처리되는 시점을 분리할 수 있다.
* N개의 클라이언트가 언제 접속하고 데이터를 전송할지 모르는 상황에서 서버가 처리 시점을 결정할 수 있다는 것은 서버 구현에 엄청난 유연성을 제공한다.