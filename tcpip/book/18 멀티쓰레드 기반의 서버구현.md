# 18 멀티쓰레드 기반의 서버구현

## 18-1 쓰레드의 이론적 이해

### 쓰레드의 등장배경

* 멀티프로세스 기반의 단점
    * 프로세스 생성이라는 부담스러운 작업과정
    * 두 프로세스 사이에서의 데이터 교환을 위해서 별도의 IPC 기법을 적용해야 함
    * 크리티컬한 이유: 수십 ~ 수천 번까지 일어나는 컨텍스트 스위칭에 따른 부담

* 컨텍스트 스위칭이란?
    * 실행중인 둘 이상의 프로세스들은 CPU 할당시간을 매우 작은 크기로 쪼개서 서로 나누어서 사용한다.
    * CPU의 할당 시간을 나누기 위해서 '컨텍스트 스위칭' 과정을 거친다.
        * 실행중인 A 프로세스의 뒤를 이어 B 프로세스를 컨텍스트 스위칭한다고 가정.
        * A 관련 데이터를 메인 메모리에서 내리고 하드디스크로 이동시킨다.
        * 그 후 B 관련 데이터를 메인 메모리에 올린다. 이것이 컨텍스트 스위칭이다.
        * 하드디스크로 이동하는 비용이 크고 시간이 오래 걸린다.
* 이 컨텍스트 스위칭을 극복하기 위해 '쓰레드'라는 것이 등장
    * 단점을 아주 없애는 것이 아니라 최소화하기 위해서 고안.
    * 경량화 된 프로세스라고 보면 된다.
    * 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠름.
    * 쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요치 않음.

### 쓰레드와 프로세스의 차이점

* 프로세스의 메모리 구조
    * 전역변수가 할당되는 데이터 영역
    * 동적 할당이 이뤄지는 힙 영역
    * 함수 실행에 사용되는 스택 영역

* 쓰레드의 등장
    * 위의 프로세스 기준으로 둘 이상의 실행흐름을 갖는 것이 목적이라면 스택 영역만 분리시키면 된다.
    * 컨텍스트 스위칭 시 데이터 영역과 힙은 올리고 내릴 필요가 없다.
    * 데이터 영역과 힙을 이용해서 데이터를 교환할 수 있다.

* 쓰레드 메모리 구조.
    * 쓰레드의 공유 힙 영역
    * 쓰레드 공유 데이터 영역
    * N개 쓰레드의 N개 스택 영역

* 프로세스와 쓰레드의 정의
    * 프로세스: 운영체제 관점에서 별도의 실행흐름을 구성하는 단위
    * 쓰레드: 프로세스 관점에서 별도의 실행흐름을 구성하는 단위

## 18-2 쓰레드의 생성 및 실행

### 쓰레드의 생성과 실행흐름의 구성

* 쓰레드 생성
    * 쓰레드는 별도의 실행흐름을 갖기 때문에 쓰레드만의 main 함수를 별도로 정의해야 한다.
    * 그리고 이 함수를 시작으로 별도의 실행흐름을 형성해 줄 것을 운영체제에게 요청해야 한다.

```cpp
#include <ptherad.h>
int pthread_create(
    pthread_t* restrict thread, const pthread_attr_t* restrict attr,
    void* (*start_routine)(void* ), void* restrict arg
);

/*
therad: 생성할 쓰레드의 ID 저장을 위한 변수 주소 값 전달.
attr: 쓰레드에 부여할 특성 정보의 전달.
start_routine: 쓰레드 main 함수 역할을 하는 별도 실행흐름의 시작이 되는 함수 포인터.
arg: 세 번쨰 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수.
*/
```

* 쓰레드 조인
    * thread_main 함수의 실행 시간을 정확히 예측할 수 없다.
    * 함수가 딱 필요한만큼만 대기하도록 하는 방법이 있다.

```cpp
#include <pthread.h>
int pthread_join(pthread_t thread, void** status);

/*
status: 쓰레드의 main 함수가 반환하는 값이 저장될 변수.
*/
```

### 임계영역 내에서 호출이 가능한 함수

* 임계영역: 둘 이상의 쓰레드가 동시에 동시에 실행할 수 있는 문제를 가지고 있는 영역
* 임계영역과 관련해서 함수는 두 가지로 구분
    * 쓰레드에 안전한 함수(임계영역이 없거나 있더라도 안전하게 구현된 함수)
    * 쓰레드에 안전하지 않은 함수
* 대부분의 표준함수는 쓰레드에 안전. 일부는 안전한 형태로 재구현된 함수들이 있다.
* 헤더파일 선언 매크로를 통한 방법도 있다. _REENTRANT를 정의하면 가능.
* 위의 매크로를 사용하지 않아도 컴파일 시 -D_REENTRANT 옵션을 추가하여 사용할 수 있다.

## 18-3 쓰레드의 문제점과 임계영역(Critical Section)

### 하나의 변수에 둘 이상의 쓰레드가 동시 접근하는 것이 문제

* 한 쓰레드가 하나의 변수의 연산을 완료할 떄까지, 다른 쓰레드가 접근하지 못하도록 막아야 한다.
* 이것을 동기화(Synchronization)이라 한다.

### 임계영역은 어디?

* 함수 내에 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 하나 이상의 문장으로 묶여있는 코드 블록

## 18-4 쓰레드 동기화

### 동기화의 두 가지 측면

* 동일한 메모리 영역으로 동시접근이 발생하는 상황
* 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황

### 뮤텍스(Mutex)

* Mutual Exclusion의 줄임 말로써 쓰레드의 동시접근을 허용하지 않는다는 의미.
* 화장실에 비유
    * 화장실의 접근보호를 위해 들어갈 때 문을 잠그고 나올 떄 문을 연다.
    * 화장실이 사용 중이라면, 밖에서 대기
    * 대기중인 사람이 둘 이상 될 수 있고, 이들은 대기순서에 따라 화장실에 입장한다.

* 뮤택스 생성과 소멸 함수
    ```cpp
    #include <pthread.h>
    int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr);
    int pthread_mutex_destroy(pthread_mutex_t* mutex);
    // mutex: 뮤텍스 생성시에는 뮤텍스의 참조 값 저장을 위한 변수의 주소 값 전달. 소멸 시에는 소멸하고자 하는 뮤텍스의 참조 값을 저장하고 있는 변수의 주소 값 전달.
    // attr: 생성하는 뮤텍스의 특성정보를 담고 있는 변수의 주소 값 전달, 별도의 특성을 지정하는 경우 NULL 전달.
    ```
    * 자물쇠 시스템에 해당하는 뮤텍스의 생성을 위해 pthread_mutex_t형 변수가 하나 선언되어야 한다.
    * 매크로 보다는 pthread_mutex_init 함수를 통해 초기화를 추천. 초기화 오류 발생에 대한 디버깅이 어렵다.

* 뮤택스 락, 언락
    ```cpp
    #include <pthread.h>
    int pthread_mutex_lock(pthread_mutex_t* mutex);
    int pthread_mutex_unlock(pthread_mutex_t* mutex);
    ```
    * lock ~ 임계영역 시작 ~ 임계영역 끝 ~ unlock
    * unlock을 제대로 하지 않으면 임계영역을 진입하는 함수는 블로킹 상태가 되고 빠져나가지 못하는데 이를 데드락이라 부른다.

### 세마포어(Semaphore)

* 세마포어의 생성
    ```cpp
    #include <semaphore.h>
    int sem_init(sem_t* sem, int pshared, unsigned int value);
    int sem_destroy(sem_t* sem);
    // sem: 세마포어 생성시에는 세마포어의 참조 값 저장을 위한 변수의 주소 값, 소멸 시에는 소멸하고자 하는 세마포어의 참조 값을 저장하고 있는 변수의 주소 값.
    // pshared: 0 이외의 값 전달 시, 둘 이상의 프로세스에 의해 접근 가능한 세마포어 생성. 0 전달 시 하나의 프로세스 내에 존재하는 쓰레드의 동기화 목적으로 0 전달.
    // value: 생성되는 세마포어의 초기 값 전달.
    ```

* 세마포어의 lock, unlock
    ```cpp
    #include <semaphore.h>
    int sem_post(sem_t* sem);
    int sem_wait(sem_t* sem);
    // sem: 세마포어의 참조 값을 저장하고 있는 변수의 주소 값 전달, sem_post에 전달되면 세마포어의 값 하나 증가, sem_wait 전달되면 세마포어의 값 하나 감소.
    ```
* sem_init 함수가 호출되면 운영체제에 의해 세마포어 오브젝트라는 것이 만들어 지는데, 이 곳에 세마포어 값이라 불리는 정수 하나가 기록된다.
* 세마포어 값은 0보다 작아질 수 없기 때문에 현재 0인 상태에서 sem_wait 함수를 호출하면 블로킹 상태에 놓인다.
* 다른 쓰레드가 sem_post 함수를 호출하면 세마포어의 값이 1이 되므로 블로킹 상태에서 벗어난다.
